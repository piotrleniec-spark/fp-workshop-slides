<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <a href="data.json" target="_blank" rel="noopener">
            Click me to download JSON with sample data.
          </a>
        </section>
        <section>Find all the items that are not purchasable.</section>
        <section>Sum the total number of each item in the data array.</section>
        <section>If item category = null, change it's value to 'no category'.</section>
        <section>
          Refactor this code using functional principles.
          <pre><code data-trim class="js">
            const preOrderedItems = []

            for (let i = 0; i < data.length; i++) {
              if (data[i].pre_order) {
                preOrderedItems.push(data[i])
              }
            }

            const firstItem = preOrderedItems[0]
          </code></pre>
        </section>
        <section>
          Refactor this code using functional principles.
          <pre><code data-trim class="js">
            const purchasableItemsWithVariants = []

            for (let i = 0; i < data.length; i++) {
              if (data[i].purchasable) {
                if (data[i].variants.length > 0) {
                  purchasableItemsWithVariants.push(data[i])
                }
              }
            }
          </code></pre>
        </section>
        <section>
          Refactor this code using functional principles.
          <pre><code data-trim class="js">
            const numberOfItems = data.length
            let totalPriceOfAllItemTypes = 0

            for (let i = 0; i < data.length; i++) {
              totalPriceOfAllItemTypes += data[i].price
            }

            const averagePrice = totalPriceOfAllItemTypes / numberOfItems
          </code></pre>
        </section>
        <section>
          Refactor this code using functional principles.
          <pre><code data-trim class="js">
            for (let i = 0; i < data.length; i++) {
              const nameArray = data[i].name.split(' ')
              nameArray[1] = nameArray[1].toUpperCase()
              data[i].name = nameArray.join(' ')
            }
          </code></pre>
        </section>
        <section>Find all the items that have the same variants (DIFFICULT!!!).</section>
        <section>
            One of the simplest and most widely known ciphers is a Caesar cipher, also known as a shift cipher. In a shift cipher the meanings of the letters are shifted by some set amount.

            A common modern use is the ROT13 cipher, where the values of the letters are shifted by 13 places. Thus 'A' ↔ 'N', 'B' ↔ 'O' and so on.

            Write a function which takes a ROT13 encoded string as input and returns a decoded string.

            All letters will be uppercase. Do not transform any non-alphabetic character (i.e. spaces, punctuation), but do pass them on.
        </section>
        <section>
            Return an English translated sentence of the passed binary string.

            The binary string will be space separated.

            "01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111" should be translated to "Aren't bonfires fun!?"
        </section>
        <section>
          Convert a string to spinal case. Spinal case is all-lowercase-words-joined-by-dashes.

          "This Is Spinal Tap" should be converted to "this-is-spinal-tap"
        </section>
        <section>
            The DNA strand is missing the pairing element. Take each character, get its pair, and return the results as a 2d array.

            Base pairs are a pair of AT and CG. Match the missing element to the provided character.

            Return the provided character as the first element in each array.

            For example, for the input GCG, return [["G", "C"], ["C","G"],["G", "C"]]

            The character and its pair are paired up in an array, and all the arrays are grouped into one encapsulating array.
        </section>
        <section>
          Examples:
          <ul>
            <li>"ATCGA" -> [["A","T"],["T","A"],["C","G"],["G","C"],["A","T"]]</li>
            <li>"TTGAG" -> [["T","A"],["T","A"],["G","C"],["A","T"],["G","C"]]</li>
            <li>"CTCTA" -> [["C","G"],["T","A"],["C","G"],["T","A"],["A","T"]]</li>
          </ul>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ],
        transition: 'none'
      });
    </script>
  </body>
</html>
